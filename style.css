body {
  margin: 0;
  font-family: "Segoe UI", sans-serif;
  display: flex;
  justify-content: center;
  align-items: center;
  background: linear-gradient(180deg, #dce3e9 0%, #b0bec5 100%);
  height: 100vh;
  overflow: hidden;
  touch-action: manipulation;
}

.container {
  width: 95%;
  max-width: 420px;
  text-align: center;
}

header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 8px;
}

.timer {
  font-size: 18px;
  color: #333;
}

#restartBtn {
  font-size: 24px;
  border: none;
  background: #fff;
  padding: 6px 12px;
  border-radius: 10px;
  box-shadow: 0 1px 4px rgba(0,0,0,0.2);
  cursor: pointer;
  transition: 0.2s;
}
#restartBtn:active {
  transform: scale(0.95);
}

.difficulty {
  margin: 8px 0;
}
.difficulty button {
  margin: 0 4px;
  border: none;
  background: #fff;
  padding: 6px 10px;
  border-radius: 8px;
  cursor: pointer;
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}
.difficulty button.active {
  background: #8bc34a;
  color: #fff;
}

.board {
  display: grid;
  justify-content: center;
  gap: 1px;
  margin-top: 10px;
  background: #90a4ae;
  padding: 5px;
  border-radius: 8px;
  box-shadow: 0 0 10px rgba(0,0,0,0.2);
}

.cell {
  aspect-ratio: 1 / 1;
  width: 100%;
  background: #cfd8dc;
  border-radius: 4px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 700;
  font-size: calc(1.2rem - 0.05 * var(--size, 9));
  color: #263238;
  cursor: pointer;
  user-select: none;
  transition: background 0.2s, transform 0.1s;
}
.cell.revealed {
  background: #eceff1;
  box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
}
.cell.flag {
  background: #ffeb3b;
}
.cell.mine {
  background: #e57373;
  color: #fff;
}
.cell.hint {
  background: #fff59d !important;
}

.message {
  margin-top: 12px;
  font-size: 20px;
  font-weight: 600;
}

.flag-container {
  margin-top: 15px;
  display: flex;
  justify-content: center;
}

.flag-big {
  font-size: 48px;
  border: none;
  background: #fff;
  width: 90px;
  height: 90px;
  border-radius: 50%;
  box-shadow: 0 3px 10px rgba(0,0,0,0.3);
  cursor: pointer;
  transition: 0.2s;
}
.flag-big.active {
  background: #ffeb3b;
}
.flag-big:active {
  transform: scale(0.95);
}

const tg = window.Telegram?.WebApp;
if (tg) tg.expand();

const boardEl = document.getElementById("board");
const timerEl = document.getElementById("timer");
const msgEl = document.getElementById("message");
const flagBtn = document.getElementById("flagBtn");
const restartBtn = document.getElementById("restartBtn");
const diffBtns = document.querySelectorAll(".difficulty button");

let size = 9;
let mineCount = 10;
let board = [];
let revealedCount = 0;
let isFlagMode = false;
let timer = null;
let time = 0;
let gameOver = false;
let firstClick = true;

// ==== –¢–∞–π–º–µ—Ä ====
const startTimer = () => {
  clearInterval(timer);
  time = 0;
  timerEl.textContent = "0";
  timer = setInterval(() => {
    time++;
    timerEl.textContent = time;
  }, 1000);
};

// ==== –°–æ–∑–¥–∞–Ω–∏–µ –ø—É—Å—Ç–æ–≥–æ –ø–æ–ª—è ====
function createEmptyBoard(n) {
  return Array.from({ length: n }, () =>
    Array.from({ length: n }, () => ({
      mine: false,
      revealed: false,
      flagged: false,
      count: 0
    }))
  );
}

// ==== –†–∞—Å—Å—Ç–∞–≤–ª—è–µ–º –º–∏–Ω—ã ====
function placeMines(n, skipX, skipY) {
  mineCount = Math.floor(n * n * 0.22);
  let placed = 0;
  while (placed < mineCount) {
    const x = Math.floor(Math.random() * n);
    const y = Math.floor(Math.random() * n);
    // –ù–µ —Å—Ç–∞–≤–∏–º –º–∏–Ω—É –≤ –ø–µ—Ä–≤—É—é –∫–ª–µ—Ç–∫—É –∏ –≤–æ–∫—Ä—É–≥ –Ω–µ—ë
    if (Math.abs(x - skipX) <= 1 && Math.abs(y - skipY) <= 1) continue;
    if (!board[y][x].mine) {
      board[y][x].mine = true;
      placed++;
    }
  }

  // –ü–æ–¥—Å—á—ë—Ç —á–∏—Å–µ–ª
  for (let y = 0; y < n; y++) {
    for (let x = 0; x < n; x++) {
      if (board[y][x].mine) continue;
      let count = 0;
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          const ny = y + dy, nx = x + dx;
          if (ny >= 0 && ny < n && nx >= 0 && nx < n && board[ny][nx].mine) count++;
        }
      }
      board[y][x].count = count;
    }
  }
}

// ==== –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∏–≥—Ä–æ–≤–æ–≥–æ –ø–æ–ª—è ====
function generateBoard(n) {
  board = createEmptyBoard(n);
  revealedCount = 0;
  gameOver = false;
  firstClick = true;
  msgEl.textContent = "";
  boardEl.innerHTML = "";
  boardEl.style.gridTemplateColumns = `repeat(${n}, 1fr)`;

  for (let y = 0; y < n; y++) {
    for (let x = 0; x < n; x++) {
      const cell = document.createElement("div");
      cell.classList.add("cell");
      cell.dataset.x = x;
      cell.dataset.y = y;
      cell.addEventListener("click", onCellClick);
      cell.addEventListener("contextmenu", (e) => {
        e.preventDefault();
        toggleFlag(cell, x, y);
      });
      boardEl.appendChild(cell);
    }
  }

  clearInterval(timer);
  startTimer();
}

// ==== –£—Å—Ç–∞–Ω–æ–≤–∫–∞/—Å–Ω—è—Ç–∏–µ —Ñ–ª–∞–≥–∞ ====
function toggleFlag(el, x, y) {
  const cell = board[y][x];
  if (cell.revealed) return;
  cell.flagged = !cell.flagged;
  el.classList.toggle("flag", cell.flagged);
  el.textContent = cell.flagged ? "üö©" : "";
}

// ==== –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–∞ ====
function onCellClick(e) {
  if (gameOver) return;
  const x = +e.target.dataset.x;
  const y = +e.target.dataset.y;
  const cell = board[y][x];

  // === –†–µ–∂–∏–º —Ñ–ª–∞–∂–∫–∞ ===
  if (isFlagMode) {
    if (!cell.revealed) {
      toggleFlag(e.target, x, y);
    } else {
      // –ù–∞–∂–∞–ª–∏ –ø–æ —Ü–∏—Ñ—Ä–µ –ø—Ä–∏ –∞–∫—Ç–∏–≤–Ω–æ–º —Ñ–ª–∞–∂–∫–µ ‚Äî –≤–∏–±—Ä–∞ –∏ –º–∏–≥–∞–Ω–∏–µ –∫–Ω–æ–ø–∫–∏
      if (navigator.vibrate) navigator.vibrate(30);
      flagBtn.classList.add("warn");
      setTimeout(() => flagBtn.classList.remove("warn"), 180);
    }
    return;
  }

  // –ï—Å–ª–∏ –∫–ª–µ—Ç–∫–∞ –ø–æ–¥ —Ñ–ª–∞–≥–æ–º ‚Äî –Ω–µ —Ç—Ä–æ–≥–∞–µ–º
  if (cell.flagged) return;

  // –ü–µ—Ä–≤–∞—è –∫–ª–µ—Ç–∫–∞ ‚Äî —Ä–∞—Å—Å—Ç–∞–≤–ª—è–µ–º –º–∏–Ω—ã
  if (firstClick) {
    placeMines(size, x, y);
    firstClick = false;
  }

  // –ï—Å–ª–∏ –∫–ª–∏–∫ –ø–æ —Ü–∏—Ñ—Ä–µ ‚Äî "—á–æ—Ä–¥"
  if (cell.revealed && cell.count > 0) {
    handleNumberClick(x, y);
    return;
  }

  // –ï—Å–ª–∏ –º–∏–Ω–∞
  if (cell.mine) {
    e.target.classList.add("mine");
    e.target.textContent = "üí£";
    endGame(false);
    return;
  }

  revealCell(x, y);
  checkWin();
}

// ==== –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–ª–∏–∫–∞ –ø–æ —Ü–∏—Ñ—Ä–µ ("—á–æ—Ä–¥") ====
function handleNumberClick(x, y) {
  const cell = board[y][x];
  let flagged = 0;
  let hidden = [];

  for (let dy = -1; dy <= 1; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      if (dx === 0 && dy === 0) continue;
      const ny = y + dy, nx = x + dx;
      if (ny >= 0 && ny < size && nx >= 0 && nx < size) {
        const ncell = board[ny][nx];
        if (ncell.flagged) flagged++;
        else if (!ncell.revealed) hidden.push({ x: nx, y: ny });
      }
    }
  }

  if (flagged === cell.count) {
    hidden.forEach(({ x, y }) => revealCell(x, y));
    checkWin();
  } else {
    // –ü–æ–¥—Å–≤–µ—Ç–∫–∞ –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏—Ö –∫–ª–µ—Ç–æ–∫
    hidden.forEach(({ x, y }) => getCellEl(x, y).classList.add("hint"));
    setTimeout(() => {
      hidden.forEach(({ x, y }) => getCellEl(x, y).classList.remove("hint"));
    }, 500);
  }
}

// ==== –û—Ç–∫—Ä—ã—Ç–∏–µ –∫–ª–µ—Ç–∫–∏ ====
function revealCell(x, y) {
  const cell = board[y][x];
  if (cell.revealed || cell.flagged) return;
  cell.revealed = true;
  revealedCount++;
  const el = getCellEl(x, y);
  el.classList.add("revealed");
  if (cell.count > 0) {
    el.textContent = cell.count;
  } else {
    // flood-fill
    for (let dy = -1; dy <= 1; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        const ny = y + dy, nx = x + dx;
        if (ny >= 0 && ny < size && nx >= 0 && nx < size) revealCell(nx, ny);
      }
    }
  }
}

// ==== –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ ====
function getCellEl(x, y) {
  return boardEl.querySelector(`.cell[data-x="${x}"][data-y="${y}"]`);
}

function revealMines() {
  for (let y = 0; y < size; y++) {
    for (let x = 0; x < size; x++) {
      const cell = board[y][x];
      if (cell.mine) {
        const el = getCellEl(x, y);
        el.classList.add("mine");
        el.textContent = "üí£";
      }
    }
  }
}

function checkWin() {
  const totalSafe = size * size - mineCount;
  if (revealedCount >= totalSafe) endGame(true);
}

function endGame(win) {
  gameOver = true;
  clearInterval(timer);
  if (!win) {
    msgEl.textContent = "üí• –ò–≥—Ä–∞ –æ–∫–æ–Ω—á–µ–Ω–∞!";
    revealMines();
  } else {
    msgEl.textContent = "üéâ –ü–æ–±–µ–¥–∞!";
    if (tg) {
      tg.sendData(JSON.stringify({ action: "sapper_score", time }));
      setTimeout(() => tg.close(), 700);
    }
  }
}

// ==== –ö–Ω–æ–ø–∫–∏ ====
flagBtn.addEventListener("click", () => {
  isFlagMode = !isFlagMode;
  flagBtn.classList.toggle("active", isFlagMode);
  flagBtn.setAttribute("aria-pressed", String(isFlagMode));
});

restartBtn.addEventListener("click", () => generateBoard(size));

diffBtns.forEach(btn => {
  btn.addEventListener("click", () => {
    diffBtns.forEach(b => b.classList.remove("active"));
    btn.classList.add("active");
    size = +btn.dataset.size;
    generateBoard(size);
  });
});

// ==== –°—Ç–∞—Ä—Ç ====
generateBoard(size);
